#!/usr/bin/env bash

readonly PROJECTS=(admiral cloud-prepare lighthouse shipyard submariner submariner-charts submariner-operator)
readonly ADMIRAL_CONSUMERS=(cloud-prepare lighthouse submariner submariner-operator)
readonly SHIPYARD_CONSUMERS=(admiral lighthouse submariner submariner-operator)
readonly OPERATOR_CONSUMES=(submariner cloud-prepare lighthouse)

readonly ORG=$(git config --get remote.origin.url | awk -F'[:/]' '{print $(NF-1)}')

function printerr() {
    local err_msg="$*"

    [[ -z "${file}" ]] || err_msg+=" (${file})"
    printf "ERROR: %s\n" "${err_msg}" >&2
}

function get_value() {
    yq r $file $key
}

function determine_target_release() {
    file=$(git diff-tree --name-only -r HEAD | grep -m1 "releases/v.*\.yaml" || :)

    if [[ -z "$file" ]]; then
        echo "WARN: Couldn't detect a target release file, skipping."
        exit 0
    fi
}

function read_release_file() {
    declare -gA release

    function _read() {
        local key=$1
        release[$key]=$(get_value $file $key)
    }

    _read 'version'
    _read 'name'
    _read 'pre-release'
    _read 'release-notes'
    _read 'status'
    _read 'branch'
    _read 'components'
    for project in ${PROJECTS[*]}; do
        _read "components.${project}"
    done
}

# Use this function to dry run a command (in dry run mode), instead of actually running the command.
# Based on global "dryrun" variable
function dryrun() {
    if [[ "$dryrun" = "true" ]]; then
        echo DRY RUNNING: "${@:Q}"
        return
    fi

    "$@"
}

function _git() {
    git -C "projects/${project}" "$@"
}

function clone_repo() {
    if [[ -d "projects/${project}" ]]; then
        _git fetch -f --tags
    else
        mkdir -p projects
        git clone "https://github.com/${ORG}/${project}" "projects/${project}"
        _git config advice.detachedHead false
    fi

}

function checkout_project_branch() {
    local base_branch="origin/${release['branch']:-devel}"
    local branch="${release["components.${project}"]:-${base_branch}}"

    _git checkout "${branch}"
}

function is_semver() {
    local ver="(0|[1-9]\d*)"
    local regex="^${ver}\.${ver}\.${ver}(-([0-9a-zA-Z.-]*))?$"
    if [[ ! "$1" =~ ${regex} ]]; then
        printerr "Version ${1@Q} is not a valid semantic version"
        return 1
    fi
}

function extract_semver() {
    declare -gA semver
    semver['major']=${1%%\.*}
    local major_minor=${1#${semver['major']}.}
    semver['minor']=${major_minor%%\.*}
    local patch_pre=${1##*\.}
    semver['patch']=${patch_pre%%-*}
    if [[ ${patch_pre} =~ - ]]; then
        semver['pre']=${patch_pre#*-}
    fi
}

